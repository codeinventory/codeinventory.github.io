---
layout: page
title:  "Programmer Competency Matrix"
date:   2015-01-01 00:00:00
categories: programmer
tags: programmer, study
---

* Source : [Programmer Competency Matrix](http://sijinjoseph.com/programmer-competency-matrix/)
* Translation : [프로그램 역량 체크](https://docs.google.com/document/d/1hnsBid61Ak7YVMerGZuxbHLFgTZ_pRwUs2-xwbkvNpc/edit)

### 컴퓨터 과학

| 구분 	|		레벨 0		|		레벨 1		|		레벨2		|		레벨3		|		기타  |
|---|---|---|---|---|---|
| **자료 구조**	|	<font color="pink">배열과 링크드 리스트의 차이를 모른다</font> | 배열, 링크드 리스트, Dictionaries 등을 설명하거나 실제 프로그래밍에서 사용할 수 있다 | 자료 구조인 배열과 링크드 리스트의 시간 대비 용량에 대한 기본적인 것을 안다 | 해시 테이블과 충돌 처리, 우선순위 큐 등에 대해 설명할 수 있고 구현할 수 있다 | 고급 자료 구조 (B-트리, binomial and fibonacci heaps, AVL/Red Black trees, Splay Trees, Skip Lists, tries 등) 에 대한 지식이 있다 |
| **알고리즘** | <font color="pink">배열의 숫자의 평균값을 찾을 수 없다</font> | 기본적인 정렬, 검색과 데이터 구조 탐색 및 탐색 알고리즘 | 트리, 그래프,  간단한 분할 정복 알고리즘을 이해할 수 있고 이 레벨의 다른 내용과의 연관성을 알 수 있다 | 동적 프로그래밍 솔루션을 이해하고 코딩할 수 있다 그래프 알고리즘에 대해서 잘 안다 수치 계산 알고리즘에 대해서 잘 안다 NP 문제를 식별할 수 있다 기타 등등 | 탑 수준의 코더와 함께 일한다는 건 믿을 수 없을 정도의  행운입니다 |
| **시스템 프로그래밍** | <font color="pink">컴파일러, 링커, 인터프리터가 뭔지 모른다	</font>	| 컴파일러와 링커, 인터프리터에 대한 기본적인 이해. 어셈블리 코드가 뭔지 이해하고 하드웨어 레벨에서 어떻게 동작하는지 안다. 가상 메모리와 페이징에 대한 약간의 지식. | 커널 모드와 유저모드, 멀티 쓰레딩, synchronization primitives 들을 이해하고 있고, 어떻게 구현되었는지 알고 있으며, 어셈블리 코드를 읽을 수 있어야 한다. 네트워크가 어떻게 동작하는지 이해하고 있고, 네트워크 프로토콜과 소켓 레벨 프로그래밍에 대해서 알고 있다 | 전체 프로그래밍 스택과 하드웨어 (CPU+메모리+캐시+인터럽트+마이크로 코드), 바이너리 코드, 어셈블리, 정적 혹은 동적 링크, compilation, interpretaton, JIT compilation, 가비지 컬렉션, 힙, 스택, 메모리 어드레싱 등에 대해서 이해하고 있다 |

### 소프트웨어 엔지니어링

구분 	|		레벨 0		|		레벨 1		|		레벨2		|		레벨3		|		기타
---|---|---|---|---|---
**소스 코드와 버전 컨트롤**		|		<font color="pink">날짜 별로 폴더 백업</font>		|		VSS와 CVS/SVN을 시작하는 유저		|		CVS와 SVN의 사용에 능숙하다 branch와 merge 등의 사용법에 대해서 안다 (본문에는 use patches setup repository properties가 포함되어 있는데 모르니 패스합니다 -_-;)		|		분산 VCS 시스템에 대해서 안다 Bzr/머큐리얼/Darcs/Git를 해보았다
**빌드 자동화**	|		IDE에서 빌드하는 법 밖에 모른다		|		커맨드 창에서 빌드하는 법을 안다		|		간단한 시스템을 빌드하는 스크립트를 만들 수 있다		|		시스템과 문서, 설치 파일, 릴리즈 문서와 소스 컨트롤의 코드 태그등을 만드는 스크립트를 만들 수 있다
**테스트 자동화**		|		테스트는 테스터가 해야 할 일이라고만 생각한다		|		이전의 코드에 대해서 자동 유닛 테스트를 작성해 보았다		|		TDD  매너에서 코드를 작성해보았다		|		자동화된 함수나 불러오기 성능, UI 테스트 등을 이해하고 만들 수 있다

### 프로그래밍

구분 	|		레벨 0		|		레벨 1		|		레벨2		|		레벨3		|		기타
---|---|---|---|---|---
**문제 파악**		|		<font color="pink">재사용하기 위해서 복붙하는 법밖에 모른다</font>		|		여러 함수 내부에서 문제를 해결할 수 있다		|		재사용 가능한 함수/오브젝트를 다룰 수 있고 그와 관련된 문제들을 해결할 수 있다		|		적절한 데이터 구조와 알고리즘을 사용하고 뭔가 바꿔야 될 문제점을 캡슐화시키는 식의 일반적/객체지향적인 코드를 작성한다.
**시스템 파악**	|		<font color="pink">하나의 파일/클래스를 벗어나지 못한다</font>		|		<font color="pink">같은 플랫폼/기술 내에서 문제 해결과 솔루션 디자인이 가능하다</font>		|		<font color="pink">여러 기술/플랫폼에 걸쳐서 시스템 디자인이 가능하다</font>		|		<font color="pink">다수의 제품 라인과 외부 시스템과 통합된 복잡한 시스템을 시각화 및 디자인 할 수 있다. 또한 모니터링, 보고, fail over와 같은 작업 지원 시스템을 설계할 수 있다.</font>
**커뮤니케이션**		|		<font color="pink">동료에게 자신의 생각이나 아이디어를 전달할 수 없다</font> <font color="pink">맞춤법과 문법이 심히 좋지 않다</font>		|		<font color="pink">동료가 말한 것을 이해할 수 있다. 맞춤법과 문법이 좋다.</font>		|		<font color="pink">동료와 효율적으로 대화가 가능하다</font> 		|		<font color="pink">생각/디자인/아이디어/스펙 등을 좋은 방식으로 이야기해서 이해하게 할 수 있고 상황에 따라서 대화를 조절할 수 있다</font> 		|		이것은 프로그램을 평가하는데 자주 사용되지만 아주 중요한 것들입니다. 영어가 모국어가 아닌 곳으로의 외주가 점점 늘어나면서 이 문제는 더 눈에 띄고 있습니다. 프로그래머가 커뮤니케이션의 의도를 알지 못해 실패한 프로젝트를 여럿 알고 있습니다
**파일 내부의 코드 구조**		|		그런거 없다		|		메소드가 논리적 혹은 접근성으로 그룹 지어져 있다		|		코드는 region에 의해 그룹화되어 있으며 다른 소스 파일에 대한 참조에 주석을 잘 달아 놓았다.		|		파일은 라이센스 헤더, 요약, 적절한 주석, 일괄적인 공백 사용이 잘 되어 있다. 보기에 매우 아름답다.
**파일간 코드 구조**		|		<font color="pink">봐도 모른다</font>		|		<font color="pink">관련된 파일들은 같은 폴더 내부에 있다</font>		|		각 물리적인 파일은 고유한 목적을 가지고 있다. 예를 들면 하나의 클래스 라든지 하나의 기능 구현 등		|		물리적 레벨에서의 코드 구성은 디자인과 일치하며 파일 이름과 폴더 분포를 보는 것으로 디자인이 무엇인지 깨달을 수 있도록 한다.
**소스 트리 구조**		|		<font color="pink">폴더 하나에 전부 넣는다</font>		|		<font color="pink">폴더 별로 코드를 분리해 놓았다</font>		|		순환 종속 없음, 바이너리, 라이브러리, 문서, 빌드, 3자 코드들이 적절한 폴더로 구성되어 있다		|		소스 트리의 물리적 레이아웃은 논리 계층 및 구성과 일치한다. 디렉토리 이름과 구성은 시스템의 디자인이 무엇인지 깨달을 수 있도록 한다. 		|		앞의 항목과의 차이는 구조의 규모, 소스 시스템을 정의하는 전반적인 아티펙트들의 세트와 관련된 트리 구조이다.
**코드 가독성**	|		<font color="pink">대충 단어 하나로</font> 		|		파일, 함수, 클래스, 메소드에 좋은 이름을 지어주었다		|		긴 함수,  묘한 코드에 대해 설명하는 주석, 버그 수정 , 가설 코드가 없다		|		가설 코드는 asset를 사용하여 검증되어 있다		|		코드는 자연스럽게 흐르며 조건문이나 메소드가 깊게 중첩되어 있지 않다
**방어적 코딩**		|		컨셉 자체를 이해를 못한다		|		모든 인자를 확인하고 코드의 위험한 부분에 대해서 경고한다		|		반환 값을 확인하고 코드에서 일어날 수 있는 전반적인 에러에 대해 검사한다		|		방어적 코딩을 돕고 실수를 시뮬레이팅하는 유닛 테스트를 작성하는 자신만의 라이브러리를 가지고 있다
**에러 처리**		|		<font color="pink">잘 되기를 빈다</font>		|		<font color="pink">기본적인 에러 처리를 한다. throw exception 과 에러 생성</font> 		|		프로그램의 상태와 리소스, 연결이 좋고 메모리가 모두 청소되어 있다면 에러/예외 처리는 프로그램에 맡긴다		|		이전에 일어난 가능한 예외들을 검출하는 코드가 코드의 모든 계층에서 일괄된 예외 처리 전략을 유지하고, 전체 시스템에 대한 예외 처리 지침을 마련한다.
**IDE**		|		<font color="pink">대부분 텍스트 편집하기 위해서 사용한다</font>		|		인터페이스에 대해서 알고 메뉴를 사용해서 IDE를 효율적으로 사용할 수 있다		|		대부분의 명령에 대한 키보드 단축키를 알고 있다		|		커스텀 매크로를 작성해보았다
**API**		|		<font color="pink">자주 문서를 집중해서 봐야 한다</font>			|		자주 사용하는 API를 기억하고 있다		|		API에 대한 광범위하고 깊은 지식		|		자주 사용하는 작업을 단순화하고 API의 공백을 채우기 위해서 API의 상단에 라이브러리를 작성해보았다		|		API의 예라면 자바 라이브러리, 닷넷 프레임워크나 애플리케이션을 위한 커스텀  API 등이 있다.
프레임워크		|		<font color="pink">코어 플랫폼 외부의 프레임워크를 써본 적이 없다</font>		|		<font color="pink">들어보기는 했지만 써보지는 않았다.	</font>	|		전문적으로 하나 이상의 프레임워크를 사용해본 적이 있으며 프레임워크의 숙어가 익숙하다		|		프레임워크 저자
**요구 사항**		|		<font color="pink">그냥 받은 대로 쓴다<d/el>		|		<font color="pink">요구 사항에서 빠진 부분에 대한 질문을 한다</font>		|		<font color="pink">전체 그림을 이해할 수 있고 전체 부분에서 필요한 것이 무언인지 찾는다</font>		|		좋은 대안을 제시할 수 있고 경험을 바탕으로 주어진 요구 사항에 맞추어 진행할 수 있다
**스크립팅**		|		<font color="pink">스크립팅 툴 따위 모른다</font>		|		<font color="pink">batch 파일 / 셀 스크립트</font>		|		<font color="pink">펄/파이썬/루비/VB스크립트/파워쉘	</font>	|		재 사용 가능한 코드를 작성하고 배포해보았다
**데이터베이스**		|		<font color="pink">액셀이 DB라는건 안다</font>		|		<font color="pink">기본적인 데이터베이스 개념, 정규화 ACID, 트랜잭션을 알고 간단한 select 를 사용할 수 있다</font>		|		실행될 쿼리, 능숙한 뷰 사용, 저장 프로시져, 트리거 및 사용자 정의 유형을 염두에 두고 정규화된 좋은 데이터베이스를 디자인할 수 있다. 클러스터와 논 클러스터 인덱스간의 차이를 알고 있다. ORM 툴의 사용에 능숙하다.		|		기본적인 데이터베이스 관리, 성능 최적화, 인덱스 최적화, 고급 select 쿼리 작성, 관계형 sql로 커서 사용을 대체 가능, 내부 데이터 저장 방식 이해, 인덱스 내부 저장 방식 이해, 데이터베이스 미러링 혹은 복제 방법 이해 등이 가능하다. 2 단계 커밋이 어떻게 동작하는지 안다.

`코드 가독성 레벨2 가설 코드 (code assumptions)`
해석을 어떻게 해야 될지 몰라서 저렇게 적었는데 동작이 제대로 되는지 어떤지 확인되지 않은 코드라고 이해하시면 되겠습니다


### 경험

구분 	|		레벨 0		|		레벨 1		|		레벨2		|		레벨3		|		기타
---|---|---|---|---|---
**전문적으로 경험한 언어**		|		<font color="pink">객체 지향 아니면 절차 지향	</font>	|		절차 지향, 객체 지향 및 선언 (SQL), static과 동적 타이핑, weak와 strong 타이핑 및 정적 추론 유형인지 		|		함수형 프로그래밍, 느긋한 계산법, 커링, continuations을 알고 있다면 보너스 추가		|		Concurrent (Erlang, Oz) 와 로직 (Prolog)
**전문적으로 경험해본 플랫폼 수**		|		<font color="pink">1</font>		|		2-3		|		4-5		|		6-
**전문 경험을 쌓은 연수**		|		<font color="pink">1</font>		|		<font color="pink">2-5</font>		|		6-9		|		10
**도메인 지식**		|		<font color="pink">도메인이 뭔지 잘 모른다</font>		|		<font color="pink">도메인에서 최소 하나의 제품에서 일해봤다</font>		|		<font color="pink">같은 도메인에서 여러 제품으로 작업해보았다</font>		|		도메인 전문가. 도메인에서 여러 제품/솔루션을 디자인하고 구현해보았다. 도메인에서 사용하는 표준 용어, 프로토콜에 능숙하다.

함수형 프로그래밍에 대한 설명 (위키 백과) : http://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D 


### 지식

구분 	|		레벨 0		|		레벨 1		|		레벨2		|		레벨3		|		기타
---|---|---|---|---|---
**툴 지식**		|		주요 IDE에 대한 기초적인 것만 안다		|		유명한 툴의 대용품과 기본적인 툴을 알고 있다		|		에디터, 디버거, IDE, 대신할만한 오픈 소스 등에 대해서 잘 알고 있다. ORM 툴을 사용해보았다.		|		툴과 스크립트를 실제로 작성해보았다 (출시해봤다면 보너스 추가)
**노출된 언어**		|		<font color="pink">객체 지향 아니면 절차 지향	</font>	|		절차 지향, 객체 지향 및 선언 (SQL), static과 동적 타이핑, weak와 strong 타이핑 및 정적 추론 유형인지 		|		함수형 프로그래밍, 느긋한 계산법, 커링, continuations을 알고 있다면 보너스 추가		|		Concurrent (Erlang, Oz) 와 로직 (Prolog)
**코드 베이스 지식**		|		코드 베이스에 대해 자세히 본 적이 없다		|		코드 레이아웃에 대한 기본적인 지식과 시스템을 짜는 방법을 안다		|		코드 베이스에 대해서 잘 알고 몇 가지 버그를 수정하거나 몇몇 작은 기능을 추가해보았다		|		몇몇 큰 기능을 코드 베이스에 추가해보았고 주요 기능의 변경점이나 버그 픽스에 대해서 쉽게 시각화할 수 있다
**차세대 기술에 대한 지식**		|		<font color="pink">들어본 적도 없다</font>		|		현장에서 차후 사용될 기술에 대해 들어봤다		|		알파 프리뷰/CTP/베타를 다운로드 받아보았고, 몇몇 기사/매뉴얼을 읽어보았다		|		프리뷰를 돌려보았고 실제로 빌드해보았으며 다른 사람에게 그것을 공유해보았다
**플랫폼 내부**	|		그냥 모른다		|		플랫폼이 내부에서 어떻게 동작하는지 기본적인 건 안다		|		플랫폼 내부에 대해 깊게 알고 있으며 프로그램이 어떻게 돌아가는지 시각화할 수 있으며 그것을 실행 가능한 코드로 변환할 수 있다		|		플랫폼 내부에 대한 정보를 제공하거나 성능을 증가시키는 툴을 작성해보았다. 예를 들면 디스어셈블러, 디컴파일러, 디버거 등
**책**		|		<font color="pink">21일 만에 배우는 xxx 같은 것들</font>		|		코드 완성하기, 생각하지 않게 하기, 정규식 표현 마스터하기		|		디자인 패턴, peopleware, 펄 프로그래밍, 알고리즘 디자인 매뉴얼, 실용주의 프로그래머, Mythical Man month		|		컴퓨터 프로그램의 구조와 해석, 기술 컨셉, 컴퓨터 프로그래밍의 모델, 컴퓨터 프로그래밍 아트, 데이터베이스 시스템, Thinking Forth, Little Schemer
**블로그**		|		<font color="pink">들어는 봤지만 할 시간은 없다</font>		|		<font color="pink">기술/프로그래밍/소프트웨어 엔지니어링 블로그를 읽고 팟캐스트를 규칙적으로 듣는다</font>		|		<font color="pink">유용한 기사와 툴을 모아 놓은 블로그를 즐겨찾기 해두었다</font>		|		<font color="pink">프로그래밍에 대한 개인적인 시각과 생각을 공유하는 블로그를 본다</font>



